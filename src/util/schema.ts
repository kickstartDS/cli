
import winston from 'winston';
import chalkTemplate from 'chalk-template';
import refParser, { FileInfo } from "json-schema-ref-parser";
import merge from "json-schema-merge-allof";
import traverse from "json-schema-traverse";
import { dirname, basename } from 'path';
import glob from "fast-glob";
import fsExtra from "fs-extra";
import { JSONSchema7 } from 'json-schema';
import { SchemaUtil } from '../../types/index.js';

/* dereferenceSchemas */
const readJSON = fsExtra.readJSON;
const $RefParser = refParser.default;

// TODO this one, too, is a poor mans version of @kickstartds/jsonschema-utils mergeAnyOfEnums
// which is also used inside the kickstartDS-schema-toolkit for the same purpose
// Should vanish with the rest of the duplicated JSON Schema stuff here
// TODO adding insult to injury: fixed .ts types by adding a bunch of `any`, and falling back
// on potentially empty strings with `|| ''`
const mergeAnyOfEnums = (schema: JSONSchema7) => {
  traverse(schema, {
    cb: (subSchema, pointer, rootSchema) => {
      const propertyName = pointer.split('/').pop();

      if (
        subSchema.anyOf &&
        subSchema.anyOf.length === 2 &&
        subSchema.anyOf.every((anyOf: any) => anyOf.type === 'string' && anyOf.enum) &&
        rootSchema.allOf &&
        rootSchema.allOf.length === 2 &&
        rootSchema.allOf.some((allOf: any) => allOf.properties[propertyName || '']?.type === 'string')
      ) {
        subSchema.type = subSchema.anyOf[0].type;
        subSchema.default = subSchema.anyOf[0].default;
        subSchema.enum = subSchema.anyOf.reduce((enumValues: any, anyOf: any) => {
          anyOf.enum.forEach((value: any) => {
            if (!enumValues.includes(value)) enumValues.push(value);
          });

          return enumValues;
        }, []);

        delete rootSchema.allOf[rootSchema.allOf.findIndex((allOf: any) => allOf.properties[propertyName || '']?.type === 'string')].properties[propertyName || ''];
        delete subSchema.anyOf;
      }
    },
  });
};

/* generateComponentPropTypes */
// @see https://github.com/bcherny/json-schema-to-typescript#not-expressible-in-typescript
// TODO fix use of `any` here
function removeUnsupportedProps(obj: any) {
  for (const prop in obj) {
    if (prop === "oneOf") delete obj[prop];
    else if (typeof obj[prop] === "object") removeUnsupportedProps(obj[prop]);
  }
  return obj;
}

const options = {
  bannerComment:
    "/* eslint-disable */\n/**\n* This file was automatically generated by json-schema-to-typescript.\n* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,\n* and run `yarn run schema` to regenerate this file.\n*/",
};

export default (logger: winston.Logger): SchemaUtil => {
  const subCmdLogger = logger.child({ utility: true });

  const dereferenceSchemas = async (
    schemaPaths: string[],
    callingPath: string,
    componentsPath: string,
    schemaDomain: string,
  ) => {
    const kdsUrlRegExp = new RegExp(`^http:\/\/schema\.kickstartds\.com\/([a-z-_]+)\/([a-z-_/]+)\.(?:schema|definitions)\.json$`, 'i');

    const kdsResolver = {
      canRead: new RegExp(`^http:\/\/schema\.kickstartds\.com`, 'i'),
      async read(file: FileInfo) {
        const result = kdsUrlRegExp.exec(file.url);
        if (result && result.length > 2) {
          const [, module, name] = result;
          const [resolvedPath] = await glob(
            `${callingPath}/node_modules/@kickstartds/${module}/lib/${name === 'lightbox-lazy-image' ? 'lightbox-image' : name}/${name}.(schema|definitions).json`
          );
          return readJSON(resolvedPath);
        }
      },
    };

    const customUrlRegExp = new RegExp(`^http:\/\/${schemaDomain.replaceAll('.', '\.')}\/([a-z-_]+)\.(?:schema|definitions)\.json$`);

    const customResolver = {
      canRead: new RegExp(`^http:\/\/${schemaDomain.replaceAll('.', '\.')}`, 'i'),
      async read(file: FileInfo) {
        const result = customUrlRegExp.exec(file.url);
        if (result && result.length > 1) {
          const [, name] = result;
          const [resolvedPath] = await glob(
            `${callingPath}/${componentsPath}/**/${name}/${name}.(schema|definitions).json`
          );
          return readJSON(resolvedPath);
        }
      },
    };

    const parseSchema = (
      schemaPath: string,
    ) =>
      new $RefParser().dereference(schemaPath, {
        resolve: {
          kds: {
            order: 1,
            ...kdsResolver,
          },
          custom: {
            order: 2,
            ...customResolver,
          },
        },
      }) as Promise<JSONSchema7>;

    const dereffedSchemas = await Promise.all(schemaPaths.map((schemaPath) => parseSchema(schemaPath)) as Promise<JSONSchema7>[]);
    dereffedSchemas.forEach(mergeAnyOfEnums);
    const mergedSchemas = dereffedSchemas.map((schema) => merge(schema, { ignoreAdditionalProperties: true }));

    subCmdLogger.info(chalkTemplate`dereferencing {bold ${schemaPaths.length} component definitions}`);
    return mergedSchemas;
  };

  const generateComponentPropTypes = async (
    schemas: JSONSchema7[],
  ) => {
    subCmdLogger.info(chalkTemplate`generating component prop types for {bold ${schemas.length}} component schemas`)

    // schemas.forEach((dereffed) => {
    //   if (
    //     !(
    //       dereffed.title &&
    //       (dereffed.properties || dereffed.allOf || dereffed.$ref)
    //     )
    //   )
    //     return;
    //   const schema = { ...dereffed };
    //   const basename = basename(schemaPath, ".json");
    //   const dirname = dirname(schemaPath);
    //   schema.title += " Props";
    //   removeUnsupportedProps(schema);
    //   const ts = await compile(schema, schema.title, options);
    // });

    // return
    return {
      demo: 'test'
    }
  };

  return {
    helper: {
      dereferenceSchemas,
      generateComponentPropTypes,
    }
  };
};
